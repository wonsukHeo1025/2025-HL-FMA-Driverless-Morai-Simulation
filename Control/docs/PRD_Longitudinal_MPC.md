# **MPC 기반 종방향 제어기 개발 계획**

본 계획은 MORAI 시뮬레이터 환경에서 제공되는 Hyundai Ioniq 5 차량 모델의 종방향 동특성을 모델링하고, 이를 기반으로 모델 예측 제어(MPC) 기법을 적용하여 목표 속도를 추종하는 제어기를 개발하는 것을 목표로 함. 모든 실험과 개발은 ROS1 Noetic 환경에서 진행됨.

## **Phase 1: 시스템 식별 (System Identification)**

MPC의 성능은 모델의 정확성에 크게 의존하므로, 가장 우선적으로 제어 대상인 차량의 동특성을 정확히 파악하는 단계가 필요함. 

물리적 원리 기반 모델링 대신, 실제 입출력 데이터를 사용하여 모델을 구축하는 데이터 기반 접근법을 채택함.

1. $\textrm F= ma$ 를 쓰려고 해도 구동력, 제동력, 공기저항, 구름저항에 해당하는 여러 파라미터값(정확한 차량 질량, 관성모멘트, 공기저항계수, 전면투영면적, 구름저항계수, 파워트레인 응답 특성 등)을 알아야 하는데 알 수 없음.
2. 구동력 및 제동력은 제어 입력에 대해 비선형적이고 시간 지연을 포함함. 공기저항도 비선형. 그냥 비선형 시스템임.  
3. 비선형성에도 불구, 선형 모델의 유용성: 빠른 제어 주기의 한 스텝에서는 종방향 동역학을 선형 근사할 수 있음. LMPC는 내부적으로 QP 문제를 풀며 NMPC보다 훨씬 연산 최적화. 또한 상태 공간 모델에 외란 상수항을 붙이는데, 이는 단순 오프셋이 아닌 특정 속도 구간에서 선형 모델로 표현되지 않는 비선형적 효과(공기저항, 구름저항 등)를 상수 외란으로 간주하여 모델이 흡수하게 하는 역할을 함. 이로 인해 모델의 정확도가 생각보다 높게 나옴. 
4. 물론 선회시 정확도가 낮아짐. 각 조향각 시나리오별로 A, B 파라미터를 만들어 게인 스케줄링을 하는 고전적인 기법이나 종방향 속도, 횡방향 속도, 요레이트를 모두 상태 변수로 포함하는 통합 모델을 만들어 accel/brake/steer를 동시에 최적화하는 다변수 MPC를 개발할 수도 있음(허나 불가능/불필요)

### **1.1. 목표**

- 차량의 종방향 동역학을 표현하는 이산 시간 상태 공간 모델을 도출함.
- 제어 입력(`accel`/`brake`)과 차량 속도 간의 관계를 정량적으로 정의함.

### **1.2. 모델 정의**

차량의 종방향 동역학은 1차 시스템으로 근사할 수 있음. 이는 계산 복잡도가 낮아 실시간 MPC에 적합하며, 대부분의 주행 시나리오에서 충분한 정확도를 보임.

- 상태 변수: $x(k) = v(k)$ (차량의 종방향 속도)
- 제어 입력: $u(k)$ (가속/감속 명령. `accel`은 양수, `brake`는 음수로 통합)
- 시스템 모델 (State-space representation):

$$

x(k+1) = A \cdot x(k) + B \cdot u(k) + d	\\						y(k) = Cx(k) + Du(k)

$$

여기서 $A$는 속도에 따른 저항(공기저항, 구름저항 등)과 관성을 포함하는 시스템 행렬, $B$는 제어 입력이 가속도에 미치는 영향을 나타내는 입력 행렬, $d$는 모델링되지 않은 외란이나 오프셋을 나타내는 상수항임. 우리의 목표는 스칼라 값인 $A$, $B$, $d$를 실험적으로 결정하는 것임.

일반적인 상태공간방정식은 행렬로 표현되지만, 우리가 다루는 단일 입력, 단일 출력 SISO 시스템에서는 스칼라 값으로 단순화됨. 

입력은 악셀/브레이크 명령, 상태 변수는 차량 속도이고 제어기 출력도 차량 속도이므로 C=1, D=0이 됨. 

### **1.3. 실험 계획**

정확하고 강인한 파라미터($A, B, d$)를 추정하기 위해, 시스템의 선형적 특성과 비선형적 특성을 모두 효과적으로 드러낼 수 있는 다각적인 실험을 설계함.

### **1.3.1. 데이터 로깅 및 제어 노드 (`system_id_node.py`)**

실험의 일관성과 재현성을 보장하기 위해, 데이터 로깅과 제어 입력 생성을 전담하는 단일 ROS 노드를 개발함.

1. **노드 기능 정의**
    - **발행**: `/ctrl_cmd` (`morai_msgs/CtrlCmd`) 토픽을 100Hz의 일정한 주기로 발행함. (ROS `Timer` 사용)
    - **구독**:
        - `/imu` (`sensor_msgs/Imu`): 50Hz
        - `/gps` (`morai_msgs/GPSMessage`): 25Hz
    - **동기화**: 주기가 다른 두 센서 데이터를 정확히 동기화하기 위해 `message_filters.TimeSynchronizer`를 사용함. IMU 메시지 수신 시점에 가장 가까운 GPS 메시지를 짝지어 콜백 함수를 트리거함.
    - **실시간 속도 추정**:
        - **주력 방식 (IMU 적분)**: 동기화된 콜백 함수 내에서, 이전 속도 값에 IMU의 `linear_acceleration.x`를 적분하여 현재 속도를 계산함. ($v_k = v_{k-1} + a_k \cdot \Delta t$)
        - **보조/검증 방식 (GPS 미분)**: GPS의 위도/경도를 UTM 좌표계로 변환 후, 위치 변화량을 시간으로 나누어 속도를 계산. 이는 IMU 적분 속도의 드리프트를 검증하는 용도로 사용함.
    - **로깅**: 동기화된 타임스탬프를 기준으로, `[timestamp, accel_cmd, brake_cmd, estimated_velocity, imu_accel_x, gps_velocity]` 형식의 데이터를 내부 리스트에 저장하고, 실험 종료 시 단일 CSV 파일로 저장함. `rosbag`은 원본 데이터 백업용으로 병행하여 기록.

### **1.3.2. 정적 특성 파악: 다단계 스텝 응답(Multi-level Step Response) 실험**

1. **목적**: 다양한 속도 영역과 가/감속 구간에서 시스템의 정상 상태 이득(steady-state gain)과 비선형성을 확인함.
2. **절차 (자동화 스크립트)**:
    - **가속 실험**:
        1. 차량을 정지 상태로 초기화.
        2. `accel` 입력을 0.1부터 0.9까지 0.1씩 증가시키는 `for` 루프 실행.
        3. 각 `accel` 레벨에 대해, 100Hz로 15초간 동일한 `/ctrl_cmd` 메시지를 발행.
        4. 다음 레벨로 넘어가기 전, 2초간 `accel=0, brake=0`을 발행하여 과도 상태를 안정화.
    - **감속 실험**:
        1. `accel=0.8`로 차량을 최고 속도에 가깝게 안정적으로 주행시킴.
        2. `brake` 입력을 0.1부터 0.9까지 0.1씩 증가시키는 `for` 루프 실행.
        3. 각 `brake` 레벨에 대해, 100Hz로 15초간 동일한 `/ctrl_cmd` 메시지를 발행.
        4. 다음 레벨로 넘어가기 전, 다시 최고 속도로 복귀.
    - **데이터 분리**: 각 스텝 실험은 별도의 CSV 파일(`step_accel_0.1.csv`, `step_brake_0.1.csv` 등)로 저장하여 분석 용이성을 확보함.

### **1.3.3. 동적 특성 파악: 주파수 응답(Frequency Response) 실험**

단순 PRBS를 넘어, 시스템의 동적 응답을 체계적으로 분석할 수 있는 입력 신호를 사용함.

1. **PRBS (Pseudo-Random Binary Sequence) 실험**
    - **목적**: 넓은 주파수 대역에 걸쳐 시스템을 '무작위로' 가진하여, 예측하지 못한 동특성을 포함한 풍부한 데이터를 얻음.
    - **절차**:
        - `accel` 입력 값을 두 레벨(예: `u_low = 0.1`, `u_high = 0.7`) 사이에서 전환.
        - 전환 시간 간격을 0.2초 ~ 2.0초 사이에서 균등 분포로 무작위 샘플링하여, 단조로운 패턴을 방지함.
        - 총 3분간 주행 데이터를 기록.
2. **처프 신호(Chirp Signal) 실험**
    - **목적**: 시스템이 어떤 주파수의 입력에 잘 반응하고, 어떤 주파수부터 반응이 느려지는지를 정량적으로 파악하기 위함 (Bode Plot 분석의 기반).
    - **절차**:
        - 주파수가 시간에 따라 선형적으로 증가하는 사인파 형태의 `accel` 입력을 생성.
        - 입력 신호: $u(t) = u_{offset} + A_{chirp} \cdot \sin(2\pi f(t) \cdot t)$
        - 파라미터 설정 예시:
            - $u_{offset} = 0.4$ (차량이 정지하지 않고 계속 움직이도록)
            - $A_{chirp} = 0.3$ (입력이 0.1 ~ 0.7 사이에서 움직이도록)
            - 시작 주파수 $f_{start} = 0.05 \text{ Hz}$ (매우 느린 변화)
            - 종료 주파수 $f_{end} = 5 \text{ Hz}$ (제어기가 반응하기 어려운 빠른 변화)
            - 총 실험 시간 $T = 120$초
        - 이 입력 신호를 100Hz로 발행하며 데이터 기록.

---

### **1.4. 데이터 처리 및 파라미터 추정**

수집된 데이터를 정제하고, 모델의 신뢰도를 검증하는 단계를 포함함.

1. **데이터 전처리 및 병합 (Python, Pandas/Numpy)**
    - **데이터 로드**: 모든 실험(step, PRBS, chirp)에서 생성된 CSV 파일들을 `pandas` DataFrame으로 불러옴.
    - **데이터 정제**:
        - 스텝 응답 데이터의 경우, 입력이 바뀐 직후의 과도 구간(transient)을 제외하고, 시스템이 안정적으로 반응하는 구간만 슬라이싱하여 사용.
        - 모든 데이터에서 `accel`과 `brake`를 단일 제어 입력 `u`로 통합 (`u = accel - brake`).
    - **데이터셋 분할**: 전체 데이터를 무작위로 섞어 학습용(Training set, 70%)과 검증용(Validation set, 30%)으로 분할함. 모델은 학습용 데이터로만 만들고, 검증용 데이터는 모델 성능 평가에만 사용함.
2. **파라미터 추정 (`numpy.linalg.lstsq`)**
    - **학습용 데이터**를 사용하여 $\mathbf{y} \approx \mathbf{M}\mathbf{p}$ 형태의 행렬을 구성.
    - `p_hat = np.linalg.lstsq(M_train, y_train, rcond=None)[0]` 코드를 통해 최적의 파라미터 $\hat{\mathbf{p}} = [\hat{A}, \hat{B}, \hat{d}]^T$ 를 계산.
3. **모델 검증 (가장 중요한 단계)**
    - **목적**: 추정된 모델이 한 번도 보지 못한 데이터(검증용 데이터)에 대해서도 실제 차량의 움직임을 얼마나 잘 예측하는지 평가.
    - **절차**:
        1. 검증용 데이터셋의 첫 번째 속도 값($v_{val}$)과 전체 제어 입력 시퀀스($u_{val}$)를 가져옴.
        2. 추정된 모델 $\hat{A}, \hat{B}, \hat{d}$를 사용하여, 한 스텝씩 순차적으로 속도를 예측함 (1-step-ahead prediction).
            
            
            $v_{pred}[k+1] = \hat{A} \cdot v_{val}[k] + \hat{B} \cdot u_{val}[k] + \hat{d}$
            
        3. **시각적 검증**: 실제 측정된 속도($v_{val}$)와 모델이 예측한 속도($v_{pred}$)를 하나의 그래프에 겹쳐서 그림. 두 그래프가 유사한 궤적을 보일수록 좋은 모델임.
        4. **정량적 검증**: 두 시계열 데이터 간의 **RMSE(Root Mean Square Error)** 를 계산하여 모델의 평균적인 예측 오차를 수치화함. 이 값이 작을수록 정확한 모델임.

이러한 체계적인 실험과 엄격한 검증 과정을 통해, 다양한 주행 상황에서 높은 신뢰도를 갖는 종방향 모델을 확보할 수 있음.

---

## **Phase 2: MPC 제어기 설계**

시스템 모델이 완성되면, 이를 예측 모델로 사용하여 최적의 제어 입력을 계산하는 MPC를 설계함.

### **2.1. 목표**

- 제한 속도 및 물리적 제약 조건을 만족하면서 목표 속도를 안정적으로 추종.
- 급격한 가감속을 억제하여 부드러운 주행 품질 확보.

### **2.2. MPC 문제 정식화**

매 제어 주기(예: 100Hz)마다 다음 최적화 문제를 품.

1. **Cost Function (목적 함수)**
    - 예측 구간($N_p$) 동안의 목표 속도 추종 오차와 제어 입력의 크기(또는 변화량)를 최소화하는 것을 목표로 함.
    
    $J(k) = \sum_{i=1}^{N_p} \| x(k+i|k) - x_{ref}(k+i) \|^2_Q + \sum_{i=0}^{N_c-1} \| u(k+i|k) \|^2_R$
    - $x(k+i|k)$: 현재 시점 $k$에서 예측한 $i$ 스텝 후의 속도
    - $x_{ref}(k+i)$: $i$ 스텝 후의 목표 속도
    - $u(k+i|k)$: 현재 시점 $k$에서 계산할 $i$ 스텝 후의 제어 입력
    - $N_p$: 예측 구간 (Prediction Horizon)
    - $N_c$: 제어 구간 (Control Horizon), $N_c \le N_p$
    - $Q, R$: 추종 성능과 제어 안정성 간의 균형을 조절하는 가중치 행렬.
2. **Constraints (제약 조건)**
    - **상태 제약**: $0 \le x(k+i|k) \le v_{limit}$ (최소/최대 속도)
    - **입력 제약**: $u_{min} \le u(k+i|k) \le u_{max}$ (예: -1.0 ~ 1.0)
    - **시스템 모델**: $x(k+i+1|k) = A \cdot x(k+i|k) + B \cdot u(k+i|k) + d$

### **2.3. 파라미터 설정 및 솔버**

- **Horizon 설정**: $N_p$와 $N_c$는 제어 성능과 계산 부하 간의 트레이드오프 관계에 있음. 초기값으로 $N_p=20, N_c=5$ 정도로 설정하고 튜닝을 통해 최적화함. (제어 주기 100Hz 기준, 0.2초 예측)
- **솔버**: 위 문제는 제약 조건이 있는 선형 이차 계획법 문제임. Python 기반의 최적화 라이브러리인 `CVXPY` 또는 `casadi`를 사용하여 QP 솔버(예: OSQP, qpOASES)와 연동, 해를 구함.

---

## **Phase 3: ROS 노드 구현 및 통합**

설계된 MPC 제어기를 실제 시뮬레이터와 연동하기 위한 ROS 노드를 구현함.

### **3.1. 노드 아키텍처**

- **노드 이름**: `mpc_longitudinal_controller`
- **구독 (Subscriptions)**:
    - `/imu` (`sensor_msgs/Imu`): 현재 가속도 정보 획득.
    - `/gps` (`morai_msgs/GPSMessage`): 현재 위치 정보 획득.
    - `/target_velocity` (`std_msgs/Float64`, 직접 정의): 외부로부터 목표 속도를 입력받음.
- **발행 (Publications)**:
    - `/ctrl_cmd` (`morai_msgs/CtrlCmd`): 계산된 최종 제어 입력을 차량에 전달.

### **3.2. 제어 루프 로직**

ROS `Timer`를 사용하여 50~100Hz의 주기로 다음 로직을 반복 실행함.

1. **상태 추정**: 콜백 함수를 통해 수신된 최신 IMU, GPS 데이터를 기반으로 현재 속도 $v(k)$를 계산함.
2. **MPC 문제 구성**: 현재 속도 $v(k)$, 목표 속도 $v_{ref}$를 MPC 문제에 대입함.
3. **최적화 수행**: `CVXPY` 등의 솔버를 호출하여 최적의 제어 입력 시퀀스 $\{u^(k|k), ..., u^(k+N_c-1|k)\}$를 계산함.
4. **입력 적용**: 계산된 시퀀스 중 첫 번째 값, $u^*(k|k)$만을 실제 제어 입력으로 사용함 (Receding Horizon 원칙).
5. **메시지 변환 및 발행**:
    - $u^*(k|k) > 0$이면, `accel = u*(k|k)`, `brake = 0.0`
    - $u^*(k|k) \le 0$ 이면, `accel = 0.0`, `brake = -u*(k|k)`
    - 위 로직에 따라 `morai_msgs/CtrlCmd` 메시지를 채우고 발행함.

---

## **Phase 4: 검증 및 튜닝**

개발된 제어기의 성능을 정량적으로 평가하고 개선함.

### **4.1. 검증 시나리오**

- **정속 주행**: 일정한 목표 속도(예: 30, 60, 100 km/h)를 얼마나 오차 없이 유지하는지 평가.
- **가감속**: 정지 상태에서 목표 속도까지, 또는 고속에서 정지까지의 과도 응답 특성(오버슛, 정착 시간)을 평가.
- **Stop-and-Go**: 도심 주행을 모사하여 낮은 속도에서의 잦은 출발/정지 성능을 평가.

### **4.2. 성능 지표**

- RMSE (Root Mean Square Error) of velocity
- Overshoot / Undershoot
- Settling Time
- 제어 입력의 부드러움 (Jerk, 입력 변화량의 분산)

### **4.3. 튜닝**

- MPC 가중치($Q, R$)를 조절하여 추종 성능과 승차감(부드러움) 사이의 균형을 맞춤.
- 예측 및 제어 구간($N_p, N_c$)을 조절하여 예측 정확도와 계산 시간 사이의 균형을 맞춤.

위 계획을 순차적으로 수행하면, 체계적이고 검증 가능한 방식으로 고성능의 종방향 MPC 제어기를 확보할 수 있을 것임. 이후 노이즈가 추가된 환경에 대비하여 EKF를 이용한 상태 추정기(`robot_localization` 패키지 활용)를 통합하고, 횡방향 제어 모델을 추가하여 다변수 MPC로 확장하는 로드맵을 고려할 수 있음.